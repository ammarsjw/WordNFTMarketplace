// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Transaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("blockHash", Value.fromBytes(Bytes.empty()));
    this.set("from", Value.fromBytes(Bytes.empty()));
    this.set("value", Value.fromBigInt(BigInt.zero()));
    this.set("gasPrice", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transaction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Transaction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Transaction", id.toString(), this);
    }
  }

  static load(id: string): Transaction | null {
    return changetype<Transaction | null>(store.get("Transaction", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value!.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes | null {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes | null) {
    if (!value) {
      this.unset("to");
    } else {
      this.set("to", Value.fromBytes(<Bytes>value));
    }
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get gasPrice(): BigInt {
    let value = this.get("gasPrice");
    return value!.toBigInt();
  }

  set gasPrice(value: BigInt) {
    this.set("gasPrice", Value.fromBigInt(value));
  }
}

export class OwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OwnershipTransferred entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): OwnershipTransferred | null {
    return changetype<OwnershipTransferred | null>(
      store.get("OwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Expired extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("_bidder", Value.fromBytes(Bytes.empty()));
    this.set("_minter", Value.fromBytes(Bytes.empty()));
    this.set("_amount", Value.fromBigInt(BigInt.zero()));
    this.set("_tokenId", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Expired entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Expired must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Expired", id.toString(), this);
    }
  }

  static load(id: string): Expired | null {
    return changetype<Expired | null>(store.get("Expired", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _bidder(): Bytes {
    let value = this.get("_bidder");
    return value!.toBytes();
  }

  set _bidder(value: Bytes) {
    this.set("_bidder", Value.fromBytes(value));
  }

  get _minter(): Bytes {
    let value = this.get("_minter");
    return value!.toBytes();
  }

  set _minter(value: Bytes) {
    this.set("_minter", Value.fromBytes(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value!.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get _tokenId(): BigInt {
    let value = this.get("_tokenId");
    return value!.toBigInt();
  }

  set _tokenId(value: BigInt) {
    this.set("_tokenId", Value.fromBigInt(value));
  }
}

export class ExpiredAndNoBidsMade extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("_minter", Value.fromBytes(Bytes.empty()));
    this.set("_tokenId", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExpiredAndNoBidsMade entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExpiredAndNoBidsMade must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExpiredAndNoBidsMade", id.toString(), this);
    }
  }

  static load(id: string): ExpiredAndNoBidsMade | null {
    return changetype<ExpiredAndNoBidsMade | null>(
      store.get("ExpiredAndNoBidsMade", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _minter(): Bytes {
    let value = this.get("_minter");
    return value!.toBytes();
  }

  set _minter(value: Bytes) {
    this.set("_minter", Value.fromBytes(value));
  }

  get _tokenId(): BigInt {
    let value = this.get("_tokenId");
    return value!.toBigInt();
  }

  set _tokenId(value: BigInt) {
    this.set("_tokenId", Value.fromBigInt(value));
  }
}

export class ERC721Received extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("_operator", Value.fromBytes(Bytes.empty()));
    this.set("_to", Value.fromBytes(Bytes.empty()));
    this.set("_tokenId", Value.fromBigInt(BigInt.zero()));
    this.set("data", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ERC721Received entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ERC721Received must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ERC721Received", id.toString(), this);
    }
  }

  static load(id: string): ERC721Received | null {
    return changetype<ERC721Received | null>(store.get("ERC721Received", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _operator(): Bytes {
    let value = this.get("_operator");
    return value!.toBytes();
  }

  set _operator(value: Bytes) {
    this.set("_operator", Value.fromBytes(value));
  }

  get _to(): Bytes {
    let value = this.get("_to");
    return value!.toBytes();
  }

  set _to(value: Bytes) {
    this.set("_to", Value.fromBytes(value));
  }

  get _tokenId(): BigInt {
    let value = this.get("_tokenId");
    return value!.toBigInt();
  }

  set _tokenId(value: BigInt) {
    this.set("_tokenId", Value.fromBigInt(value));
  }

  get data(): Bytes {
    let value = this.get("data");
    return value!.toBytes();
  }

  set data(value: Bytes) {
    this.set("data", Value.fromBytes(value));
  }
}

export class Claimed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("_bidder", Value.fromBytes(Bytes.empty()));
    this.set("_minter", Value.fromBytes(Bytes.empty()));
    this.set("_amount", Value.fromBigInt(BigInt.zero()));
    this.set("_tokenId", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Claimed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Claimed must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Claimed", id.toString(), this);
    }
  }

  static load(id: string): Claimed | null {
    return changetype<Claimed | null>(store.get("Claimed", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _bidder(): Bytes {
    let value = this.get("_bidder");
    return value!.toBytes();
  }

  set _bidder(value: Bytes) {
    this.set("_bidder", Value.fromBytes(value));
  }

  get _minter(): Bytes {
    let value = this.get("_minter");
    return value!.toBytes();
  }

  set _minter(value: Bytes) {
    this.set("_minter", Value.fromBytes(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value!.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get _tokenId(): BigInt {
    let value = this.get("_tokenId");
    return value!.toBigInt();
  }

  set _tokenId(value: BigInt) {
    this.set("_tokenId", Value.fromBigInt(value));
  }
}

export class ClaimedAndNoBidsMade extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("_minter", Value.fromBytes(Bytes.empty()));
    this.set("_tokenId", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ClaimedAndNoBidsMade entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ClaimedAndNoBidsMade must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ClaimedAndNoBidsMade", id.toString(), this);
    }
  }

  static load(id: string): ClaimedAndNoBidsMade | null {
    return changetype<ClaimedAndNoBidsMade | null>(
      store.get("ClaimedAndNoBidsMade", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _minter(): Bytes {
    let value = this.get("_minter");
    return value!.toBytes();
  }

  set _minter(value: Bytes) {
    this.set("_minter", Value.fromBytes(value));
  }

  get _tokenId(): BigInt {
    let value = this.get("_tokenId");
    return value!.toBigInt();
  }

  set _tokenId(value: BigInt) {
    this.set("_tokenId", Value.fromBigInt(value));
  }
}

export class ChangedWordsNFTAddress extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("_wordsNFTAddress", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ChangedWordsNFTAddress entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ChangedWordsNFTAddress must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChangedWordsNFTAddress", id.toString(), this);
    }
  }

  static load(id: string): ChangedWordsNFTAddress | null {
    return changetype<ChangedWordsNFTAddress | null>(
      store.get("ChangedWordsNFTAddress", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _wordsNFTAddress(): Bytes {
    let value = this.get("_wordsNFTAddress");
    return value!.toBytes();
  }

  set _wordsNFTAddress(value: Bytes) {
    this.set("_wordsNFTAddress", Value.fromBytes(value));
  }
}

export class ChangedMarketplaceFeeWallet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("_marketplaceFeeWallet", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ChangedMarketplaceFeeWallet entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ChangedMarketplaceFeeWallet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChangedMarketplaceFeeWallet", id.toString(), this);
    }
  }

  static load(id: string): ChangedMarketplaceFeeWallet | null {
    return changetype<ChangedMarketplaceFeeWallet | null>(
      store.get("ChangedMarketplaceFeeWallet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _marketplaceFeeWallet(): Bytes {
    let value = this.get("_marketplaceFeeWallet");
    return value!.toBytes();
  }

  set _marketplaceFeeWallet(value: Bytes) {
    this.set("_marketplaceFeeWallet", Value.fromBytes(value));
  }
}

export class ChangedFeePercentages extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("_marketplacePercentage", Value.fromI32(0));
    this.set("_minterPercentage", Value.fromI32(0));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ChangedFeePercentages entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ChangedFeePercentages must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChangedFeePercentages", id.toString(), this);
    }
  }

  static load(id: string): ChangedFeePercentages | null {
    return changetype<ChangedFeePercentages | null>(
      store.get("ChangedFeePercentages", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _marketplacePercentage(): i32 {
    let value = this.get("_marketplacePercentage");
    return value!.toI32();
  }

  set _marketplacePercentage(value: i32) {
    this.set("_marketplacePercentage", Value.fromI32(value));
  }

  get _minterPercentage(): i32 {
    let value = this.get("_minterPercentage");
    return value!.toI32();
  }

  set _minterPercentage(value: i32) {
    this.set("_minterPercentage", Value.fromI32(value));
  }
}

export class BidMade extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("_bidder", Value.fromBytes(Bytes.empty()));
    this.set("_amount", Value.fromBigInt(BigInt.zero()));
    this.set("_tokenId", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BidMade entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BidMade must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BidMade", id.toString(), this);
    }
  }

  static load(id: string): BidMade | null {
    return changetype<BidMade | null>(store.get("BidMade", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _bidder(): Bytes {
    let value = this.get("_bidder");
    return value!.toBytes();
  }

  set _bidder(value: Bytes) {
    this.set("_bidder", Value.fromBytes(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value!.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get _tokenId(): BigInt {
    let value = this.get("_tokenId");
    return value!.toBigInt();
  }

  set _tokenId(value: BigInt) {
    this.set("_tokenId", Value.fromBigInt(value));
  }
}

export class BidCancelled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("_bidder", Value.fromBytes(Bytes.empty()));
    this.set("_amount", Value.fromBigInt(BigInt.zero()));
    this.set("_tokenId", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BidCancelled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BidCancelled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BidCancelled", id.toString(), this);
    }
  }

  static load(id: string): BidCancelled | null {
    return changetype<BidCancelled | null>(store.get("BidCancelled", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _bidder(): Bytes {
    let value = this.get("_bidder");
    return value!.toBytes();
  }

  set _bidder(value: Bytes) {
    this.set("_bidder", Value.fromBytes(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value!.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get _tokenId(): BigInt {
    let value = this.get("_tokenId");
    return value!.toBigInt();
  }

  set _tokenId(value: BigInt) {
    this.set("_tokenId", Value.fromBigInt(value));
  }
}

export class AuctionMade extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("transaction", Value.fromString(""));
    this.set("_minter", Value.fromBytes(Bytes.empty()));
    this.set("_mintTime", Value.fromBigInt(BigInt.zero()));
    this.set("_initialExpiryTime", Value.fromBigInt(BigInt.zero()));
    this.set("_tokenId", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AuctionMade entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AuctionMade must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AuctionMade", id.toString(), this);
    }
  }

  static load(id: string): AuctionMade | null {
    return changetype<AuctionMade | null>(store.get("AuctionMade", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _minter(): Bytes {
    let value = this.get("_minter");
    return value!.toBytes();
  }

  set _minter(value: Bytes) {
    this.set("_minter", Value.fromBytes(value));
  }

  get _mintTime(): BigInt {
    let value = this.get("_mintTime");
    return value!.toBigInt();
  }

  set _mintTime(value: BigInt) {
    this.set("_mintTime", Value.fromBigInt(value));
  }

  get _initialExpiryTime(): BigInt {
    let value = this.get("_initialExpiryTime");
    return value!.toBigInt();
  }

  set _initialExpiryTime(value: BigInt) {
    this.set("_initialExpiryTime", Value.fromBigInt(value));
  }

  get _tokenId(): BigInt {
    let value = this.get("_tokenId");
    return value!.toBigInt();
  }

  set _tokenId(value: BigInt) {
    this.set("_tokenId", Value.fromBigInt(value));
  }
}
